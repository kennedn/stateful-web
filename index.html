<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>API Explorer</title>
  <style>
    /* Scrollbar styling */
    * {
      box-sizing: border-box;
      scrollbar-color: rgba(255, 255, 255, 0.25) transparent;
    }
    *::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }
    *::-webkit-scrollbar-thumb {
      background-color: rgba(255, 255, 255, 0.25);
      border-radius: 4px;
    }
    *::-webkit-scrollbar-thumb:hover {
      background-color: rgba(255, 255, 255, 0.5);
    }

    :root {
      --bg: #125250;
      --card-bg: #125250;
      --text-main: #ffffff;
      --text-muted: #d0d9e5;
      --terminal-bg: #393b3d;
      --code-bg: rgba(240, 246, 252, 0.05);
      --terminal-height: 20vh;
    }

    body {
      margin: 0;
      padding: 0;
      color: var(--text-main);
      background-color: var(--bg);
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    a {
      color: white;
      font-weight: bold;
      text-decoration: none;
    }

    code, kbd, tt, samp {
      color: #e5c07b;
      background-color: var(--code-bg);
      padding: 0.1rem 0.25rem;
      border-radius: 3px;
    }

    pre {
      background-color: #393b3d;
      margin: 0;
    }

    .app {
      min-height: 100vh;
      padding: 1rem 1rem calc(var(--terminal-height) + 1rem);
    }

    .header {
      max-width: 900px;
      margin: 0 auto 0.75rem;
    }

    .header h1 {
      margin: 0 0 0.25rem;
      font-size: 1.5rem;
      color: white;
    }

    .header p {
      margin: 0;
      font-size: 0.85rem;
      color: var(--text-muted);
    }

    .main {
      max-width: 900px;
      margin: 0 auto;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    #path {
      font-size: 1.85rem;
      color: var(--text-muted);
      word-wrap: break-word;
    }

    #path span {
      margin-right: 0.1rem;
      font-weight: bold;
    }

    #path button {
      border: none;
      background: none;
      cursor: pointer;
      padding: 0;
      margin: 0;
      font-size: 1.85rem;
      color: white;
      font-weight: bold;
    }

    #items {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      margin-bottom: 0.5rem;
    }

    .row {
      width: 100%;
      padding: 0.6rem 0.75rem;
      position: relative;
      overflow: hidden;
      color: white;
      background-color: var(--card-bg);
      /* Gradient border frame like your theme */
      background-image:
        linear-gradient(to right, white 2px, transparent 2px),
        linear-gradient(to right, white 2px, transparent 2px),
        linear-gradient(to left, white 2px, transparent 2px),
        linear-gradient(to left, white 2px, transparent 2px),
        linear-gradient(to bottom, white 2px, transparent 2px),
        linear-gradient(to bottom, white 2px, transparent 2px),
        linear-gradient(to top, white 2px, transparent 2px),
        linear-gradient(to top, white 2px, transparent 2px);
      background-position:
        0 0,
        0 100%,
        100% 0,
        100% 100%,
        0 0,
        100% 0,
        0 100%,
        100% 100%;
      background-repeat: no-repeat;
      background-size: 16px 16px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.25);
      transition: transform 0.2s;
      cursor: pointer; /* whole card clickable */
    }

    /* Teal, red, purple cycling */
    .row:nth-child(3n+1) {
      background-color: #125250;
    }
    .row:nth-child(3n+2) {
      background-color: #941743;
    }
    .row:nth-child(3n) {
      background-color: #4e0277;
    }

    .row:hover {
      transform: scale(0.98);
    }

    .row:not(:hover) {
      transform: scale(1.0);
    }

    .row-inner {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 0.35rem;
    }

    .item-label {
      font-size: 1rem;
      font-weight: 600;
      flex-shrink: 0;
    }

    .item-btn {
      display: inline-block;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.5);
      padding: 0.25rem 0.7rem;
      font-size: 0.9rem;
      background: rgba(0,0,0,0.18);
      color: white;
      flex-shrink: 0;
      pointer-events: none; /* purely visual */
    }

    .value-toggle-label {
      font-size: 1rem;
      display: flex;
      align-items: center;
      gap: 0.2rem;
      color: #f0f0f0;
      flex-shrink: 0;
    }

    .value-toggle-label input {
      cursor: pointer;
    }

    .value-input,
    .range-code-input {
      padding: 0.25rem 0.45rem;
      font-size: 1rem;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.4);
      background-color: rgba(0,0,0,0.18);
      color: white;
      outline: none;
      min-width: 5rem;
    }

    .value-input::placeholder {
      color: rgba(255,255,255,0.6);
    }

    .value-input {
      display: none;
    }
    .value-input.visible {
      display: inline-block;
    }

    .range-label {
      font-size: 1rem;
      color: white;
      flex-shrink: 0;
      font-weight: 600;
    }

    @media (max-width: 600px) {
      .app {
        padding: 0.75rem 0.5rem calc(var(--terminal-height) + 0.5rem);
      }

      .range-code-input,
      .value-input {
        width: 100%;
      }

      .value-toggle-label {
        justify-content: flex-start;
      }
    }

    /* Terminal panel */
    #terminal-panel {
      position: fixed;
      left: 0;
      right: 0;
      bottom: 0;
      height: var(--terminal-height);
      min-height: 15vh;
      max-height: 80vh;
      background-color: #393b3d;
      color: white;
      border-top: 1px solid rgba(255,255,255,0.25);
      box-shadow: 0 -4px 16px rgba(0,0,0,0.6);
      display: flex;
      flex-direction: column;
      z-index: 1000;
    }

    #terminal-handle {
      height: 18px;
      cursor: ns-resize;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #2c2f31;
      border-bottom: 1px solid rgba(255,255,255,0.15);
      font-size: 0.7rem;
      color: rgba(255,255,255,0.7);
      user-select: none;
    }

    #terminal-handle-bar {
      width: 40px;
      height: 3px;
      border-radius: 999px;
      background: rgba(255,255,255,0.4);
    }

    #terminal-body {
      display: flex;
      flex-direction: column;
      padding: 0.35rem 0.6rem 0.6rem;
      height: calc(100% - 19px);
    }

    #status {
      font-size: 0.78rem;
      color: #d0d9e5;
      margin-bottom: 0.25rem;
      word-wrap: break-word;
    }

    #response {
      flex: 1;
      padding: 0.5rem;
      background-color: #111;
      color: #f5f5f5;
      border-radius: 6px;
      white-space: pre;
      overflow: auto;
      font-size: 0.82rem;
    }

    .error {
      color: #ff8080;
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="header">
      <h1>Stateful</h1>
    </div>

    <div class="main">
      <div id="path"></div>
      <div id="items">Loading…</div>
    </div>
  </div>

  <!-- Terminal panel at bottom -->
  <div id="terminal-panel">
    <div id="terminal-handle">
      <div id="terminal-handle-bar"></div>
    </div>
    <div id="terminal-body">
      <div id="status"></div>
      <pre id="response"></pre>
    </div>
  </div>

  <script>
    const BASE_URL = "http://pc.int:8080/v2";
    let currentPathSegments = [];
    let dragState = null;

    function setTerminalHeight(px) {
      const clamped = Math.min(Math.max(px, 120), window.innerHeight * 0.8);
      document.documentElement.style.setProperty("--terminal-height", clamped + "px");
    }

    function setupTerminalDrag() {
      const handle = document.getElementById("terminal-handle");

      const startDrag = (clientY) => {
        dragState = {
          startY: clientY,
          startHeight:
            parseInt(
              getComputedStyle(document.documentElement)
                .getPropertyValue("--terminal-height"),
              10
            ) || 220,
        };
        document.body.style.userSelect = "none";
        document.body.style.touchAction = "none"; // prevent scroll while dragging
      };

      const moveDrag = (clientY) => {
        if (!dragState) return;
        const dy = dragState.startY - clientY;
        const newHeight = dragState.startHeight + dy;
        setTerminalHeight(newHeight);
      };

      const endDrag = () => {
        if (!dragState) return;
        dragState = null;
        document.body.style.userSelect = "";
        document.body.style.touchAction = "";
      };

      // Mouse
      handle.addEventListener("mousedown", (e) => {
        startDrag(e.clientY);
      });

      window.addEventListener("mousemove", (e) => {
        moveDrag(e.clientY);
      });

      window.addEventListener("mouseup", endDrag);
      window.addEventListener("mouseleave", endDrag);

      // Touch
      handle.addEventListener(
        "touchstart",
        (e) => {
          const touch = e.touches[0];
          if (!touch) return;
          startDrag(touch.clientY);
        },
        { passive: true }
      );

      window.addEventListener(
        "touchmove",
        (e) => {
          if (!dragState) return;
          const touch = e.touches[0];
          if (!touch) return;
          e.preventDefault(); // stop page scrolling while dragging
          moveDrag(touch.clientY);
        },
        { passive: false }
      );

      window.addEventListener("touchend", endDrag);
      window.addEventListener("touchcancel", endDrag);

      window.addEventListener("resize", () => {
        const current =
          parseInt(
            getComputedStyle(document.documentElement)
              .getPropertyValue("--terminal-height"),
            10
          ) || 220;
        setTerminalHeight(current);
      });
    }

    function pathToString(segments) {
      if (!segments.length) return "/";
      return "/" + segments.map(encodeURIComponent).join("/");
    }

    function hashToSegments() {
      const hash = window.location.hash || "";
      // Expect formats like "#/" or "#/tvcom/volume"
      if (!hash.startsWith("#/")) return [];
      const path = hash.slice(2); // remove "#/"
      if (!path) return [];
      return path
        .split("/")
        .filter(Boolean)
        .map(decodeURIComponent);
    }

    async function fetchRaw(path, options = {}) {
      const url = BASE_URL + path;
      try {
        const res = await fetch(url, options);
        const text = await res.text();
        let json = null;
        try {
          json = text ? JSON.parse(text) : null;
        } catch (_) {
          // ignore non-JSON
        }
        return { ok: res.ok, status: res.status, json, text };
      } catch (e) {
        return { ok: false, status: 0, json: null, text: String(e) };
      }
    }

    async function fetchList(path) {
      const { ok, status, json, text } = await fetchRaw(path);
      if (!ok || status !== 200) {
        throw new Error(`${status} on ${path}: ${text || "(no body)"}`);
      }
      if (!json || !Array.isArray(json.data)) {
        throw new Error(`Unexpected response at ${path}`);
      }
      return json.data;
    }

    async function tryFetchList(path) {
      const { ok, status, json } = await fetchRaw(path);
      if (!ok || status !== 200) return null;
      if (!json || !Array.isArray(json.data)) return null;
      return json.data;
    }

    function analyzeNumericRange(items) {
      const nums = [];
      const extras = [];
      for (const item of items) {
        const n = Number(item);
        if (Number.isInteger(n) && n >= 0 && n <= 100) {
          nums.push(n);
        } else {
          extras.push(item);
        }
      }
      if (!nums.length) return { isRange: false, extras: [] };
      const min = Math.min(...nums);
      const max = Math.max(...nums);
      if (min === 0 && max === 100 && nums.length >= 50) {
        return { isRange: true, extras };
      }
      return { isRange: false, extras: [] };
    }

    function setGlobalResult(label, payload) {
      const statusEl = document.getElementById("status");
      const responseEl = document.getElementById("response");
      statusEl.textContent = label;
      responseEl.textContent =
        typeof payload === "string"
          ? payload
          : JSON.stringify(payload, null, 2);
    }

    async function postCode(pathSegments, code, extraValue) {
      const basePath = pathToString(pathSegments);
      let query = basePath + "?code=" + encodeURIComponent(code);
      if (extraValue !== null && extraValue !== undefined && extraValue !== "") {
        query += "&value=" + encodeURIComponent(extraValue);
      }

      const { ok, status, json, text } = await fetchRaw(query, { method: "POST" });
      const label = `POST ${BASE_URL}${query}`;

      if (!ok || status !== 200) {
        setGlobalResult(label, `${status} ${text || ""}`);
        return;
      }
      const body = json || text || "";
      setGlobalResult(label, body);
    }

    function renderBreadcrumb(pathSegments) {
      const pathEl = document.getElementById("path");
      pathEl.textContent = "";

      const rootBtn = document.createElement("button");
      rootBtn.textContent = "/v2";
      rootBtn.addEventListener("click", () => navigateTo([]));
      pathEl.appendChild(rootBtn);

      pathSegments.forEach((seg, idx) => {
        const sep = document.createElement("span");
        sep.textContent = "/";
        pathEl.appendChild(sep);

        const capturedPath = pathSegments.slice(0, idx + 1);

        if (idx === pathSegments.length - 1) {
          const span = document.createElement("span");
          span.textContent = seg;
          pathEl.appendChild(span);
        } else {
          const btn = document.createElement("button");
          btn.textContent = seg;
          btn.addEventListener("click", () => navigateTo(capturedPath));
          pathEl.appendChild(btn);
        }
      });
    }

    function isInteractiveTarget(target) {
      return !!target.closest("input") || !!target.closest("label");
    }

    function applyRowBackground(row) {
      const color = getComputedStyle(row).backgroundColor;
      document.body.style.backgroundColor = color;
    }

    async function renderPath(pathSegments, items) {
      currentPathSegments = pathSegments;
      renderBreadcrumb(pathSegments);

      const itemsEl = document.getElementById("items");
      itemsEl.textContent = "";

      if (!items || !items.length) {
        itemsEl.textContent = "No items.";
        return;
      }

      const rangeInfo = analyzeNumericRange(items);
      if (rangeInfo.isRange) {
        // Numeric 0–100 range row
        const row = document.createElement("div");
        row.className = "row";
        const inner = document.createElement("div");
        inner.className = "row-inner";

        const label = document.createElement("span");
        label.className = "range-label";
        label.textContent = "Code (0–100)";
        inner.appendChild(label);

        const codeInput = document.createElement("input");
        codeInput.type = "number";
        codeInput.min = "0";
        codeInput.max = "100";
        codeInput.step = "1";
        codeInput.value = "50";
        codeInput.className = "range-code-input";
        inner.appendChild(codeInput);

        const chip = document.createElement("span");
        chip.className = "item-btn";
        chip.textContent = "POST";
        inner.appendChild(chip);

        const valueToggleLabel = document.createElement("label");
        valueToggleLabel.className = "value-toggle-label";
        const valueToggle = document.createElement("input");
        valueToggle.type = "checkbox";
        valueToggleLabel.appendChild(valueToggle);
        valueToggleLabel.appendChild(document.createTextNode("with value"));
        inner.appendChild(valueToggleLabel);

        const valueInput = document.createElement("input");
        valueInput.type = "text";
        valueInput.placeholder = "value";
        valueInput.className = "value-input";
        inner.appendChild(valueInput);

        valueToggle.addEventListener("change", () => {
          if (valueToggle.checked) {
            valueInput.classList.add("visible");
          } else {
            valueInput.classList.remove("visible");
          }
        });

        row.addEventListener("click", (e) => {
          if (isInteractiveTarget(e.target)) return;
          applyRowBackground(row);
          const n = Number(codeInput.value);
          if (!Number.isInteger(n) || n < 0 || n > 100) {
            setGlobalResult("Validation", "Code must be an integer 0–100");
            return;
          }
          const extraValue = valueToggle.checked ? valueInput.value : null;
          postCode(pathSegments, String(n), extraValue);
        });

        row.appendChild(inner);
        itemsEl.appendChild(row);

        // Extras (e.g. "status") as separate leaves
        for (const extra of rangeInfo.extras) {
          const rowExtra = document.createElement("div");
          rowExtra.className = "row";
          const innerExtra = document.createElement("div");
          innerExtra.className = "row-inner";

          const labelExtra = document.createElement("span");
          labelExtra.className = "item-label";
          labelExtra.textContent = extra;
          innerExtra.appendChild(labelExtra);

          const chipExtra = document.createElement("span");
          chipExtra.className = "item-btn";
          chipExtra.textContent = "POST";
          innerExtra.appendChild(chipExtra);

          const isStatus = String(extra).toLowerCase() === "status";

          if (!isStatus) {
            const valueToggleLabel2 = document.createElement("label");
            valueToggleLabel2.className = "value-toggle-label";
            const valueToggle2 = document.createElement("input");
            valueToggle2.type = "checkbox";
            valueToggleLabel2.appendChild(valueToggle2);
            valueToggleLabel2.appendChild(
              document.createTextNode("with value")
            );

            const valueInput2 = document.createElement("input");
            valueInput2.type = "text";
            valueInput2.placeholder = "value";
            valueInput2.className = "value-input";

            valueToggle2.addEventListener("change", () => {
              if (valueToggle2.checked) {
                valueInput2.classList.add("visible");
              } else {
                valueInput2.classList.remove("visible");
              }
            });

            innerExtra.appendChild(valueToggleLabel2);
            innerExtra.appendChild(valueInput2);

            rowExtra.addEventListener("click", (e) => {
              if (isInteractiveTarget(e.target)) return;
              applyRowBackground(rowExtra);
              const extraValue =
                valueToggle2.checked ? valueInput2.value : null;
              postCode(pathSegments, extra, extraValue);
            });
          } else {
            rowExtra.addEventListener("click", (e) => {
              if (isInteractiveTarget(e.target)) return;
              applyRowBackground(rowExtra);
              postCode(pathSegments, extra, null);
            });
          }

          rowExtra.appendChild(innerExtra);
          itemsEl.appendChild(rowExtra);
        }

        return;
      }

      // Normal case: each item may be branch or leaf
      for (const item of items) {
        const row = document.createElement("div");
        row.className = "row";
        const inner = document.createElement("div");
        inner.className = "row-inner";

        const labelSpan = document.createElement("span");
        labelSpan.className = "item-label";
        labelSpan.textContent = item;
        inner.appendChild(labelSpan);

        const chip = document.createElement("span");
        chip.className = "item-btn";
        chip.textContent = "GET";
        inner.appendChild(chip);

        const childSegments = pathSegments.concat(item);
        const childPath = pathToString(childSegments);
        const isStatus = String(item).toLowerCase() === "status";

        let childList = null;
        try {
          childList = await tryFetchList(childPath);
        } catch (_) {
          childList = null;
        }

        if (childList && childList.length) {
          // Branch: clicking card navigates into deeper list
          row.addEventListener("click", (e) => {
            if (isInteractiveTarget(e.target)) return;
            applyRowBackground(row);
            navigateTo(childSegments, childList);
          });
        } else {
          // Leaf: POST; with value only for non-status
          chip.textContent = "POST";

          if (!isStatus) {
            const valueToggleLabel = document.createElement("label");
            valueToggleLabel.className = "value-toggle-label";
            const valueToggle = document.createElement("input");
            valueToggle.type = "checkbox";
            valueToggleLabel.appendChild(valueToggle);
            valueToggleLabel.appendChild(
              document.createTextNode("with value")
            );

            const valueInput = document.createElement("input");
            valueInput.type = "text";
            valueInput.placeholder = "value";
            valueInput.className = "value-input";

            valueToggle.addEventListener("change", () => {
              if (valueToggle.checked) {
                valueInput.classList.add("visible");
              } else {
                valueInput.classList.remove("visible");
              }
            });

            inner.appendChild(valueToggleLabel);
            inner.appendChild(valueInput);

            row.addEventListener("click", (e) => {
              if (isInteractiveTarget(e.target)) return;
              applyRowBackground(row);
              const extraValue =
                valueToggle.checked ? valueInput.value : null;
              postCode(pathSegments, item, extraValue);
            });
          } else {
            row.addEventListener("click", (e) => {
              if (isInteractiveTarget(e.target)) return;
              applyRowBackground(row);
              postCode(pathSegments, item, null);
            });
          }
        }

        row.appendChild(inner);
        itemsEl.appendChild(row);
      }
    }

    async function navigateTo(pathSegments, knownItems, push = true) {
      const itemsEl = document.getElementById("items");
      itemsEl.textContent = "Loading…";

      try {
        const items = knownItems || await fetchList(pathToString(pathSegments));
        await renderPath(pathSegments, items);

        if (push) {
          history.pushState(
            { pathSegments },
            "",
            "#" + pathToString(pathSegments)
          );
        }
      } catch (e) {
        itemsEl.textContent = `Error loading ${pathToString(
          pathSegments
        )}: ${e.message}`;
        itemsEl.classList.add("error");
      }
    }

    async function init() {
      setTerminalHeight(
        parseInt(
          getComputedStyle(document.documentElement)
            .getPropertyValue("--terminal-height"),
          10
        ) || 220
      );
      setupTerminalDrag();

      const initialSegments = hashToSegments();

      try {
        await navigateTo(initialSegments, null, false);

        history.replaceState(
          { pathSegments: initialSegments },
          "",
          "#" + pathToString(initialSegments)
        );
      } catch (e) {
        const itemsEl = document.getElementById("items");
        itemsEl.textContent = `Error loading ${pathToString(
          initialSegments
        ) || "/"}: ${e.message}`;
        itemsEl.classList.add("error");
      }
    }

    window.addEventListener("popstate", async (event) => {
      const pathSegments = event.state?.pathSegments || [];
      await navigateTo(pathSegments, null, false);
    });

    window.addEventListener("DOMContentLoaded", init);
  </script>
</body>
</html>
